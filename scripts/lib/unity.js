const colors = require("ansis");
const path = require("node:path");

const fs = require("node:fs");

const { CPP_SRC_FOLDER_PATH } = require("./utils");

const PROJECT_ROOT = path.resolve(__dirname, "..", "..");

function toLineDirectivePath(filePath) {
  const normalizedAbsolutePath = filePath.split(path.sep).join("/");
  const relativePath = path.relative(PROJECT_ROOT, filePath);
  if (!relativePath || relativePath.startsWith("..")) {
    return normalizedAbsolutePath;
  }
  return relativePath.split(path.sep).join("/");
}

const INCLUDE_REGEX = /^#\s*include\s+["<](.+)[">]/;
const ROARING_VERSION_REGEX = /#\s*define\s+ROARING_VERSION\s+"(.+)"/;

module.exports.unity = function unity() {
  const existsCache = new Map();

  const exists = (filePath) => {
    let result = existsCache.get(filePath);
    if (result !== undefined) {
      return result;
    }
    result = fs.existsSync(filePath);
    existsCache.set(filePath, result);
    return result;
  };

  const includedFiles = new Set();
  let roaringVersion = null;

  const output = ['// This file is generated by "scripts/build.js". Do not edit it directly.', ""];

  let pendingLineDirective = null;

  const scheduleLineDirective = (filePath, lineNumber) => {
    pendingLineDirective = { filePath, lineNumber };
  };

  const pushLine = (line) => {
    if (pendingLineDirective) {
      const { filePath, lineNumber } = pendingLineDirective;
      output.push(`#line ${lineNumber} "${toLineDirectivePath(filePath)}"`);
      pendingLineDirective = null;
    }
    output.push(line);
  };

  function processFile(filePath) {
    const content = fs.readFileSync(filePath, "utf8");
    const lines = content.split(/\r?\n/);

    scheduleLineDirective(filePath, 1);

    for (let index = 0; index < lines.length; index += 1) {
      const lineNumber = index + 1;
      const line = lines[index];
      const includeMatch = line.match(INCLUDE_REGEX);
      if (includeMatch) {
        const includeName = includeMatch[1];

        let includePath;
        if (includeName.startsWith("roaring/") && line.includes("<")) {
          includePath = path.resolve(__dirname, "../../submodules/CRoaring/include", includeName);
        } else {
          includePath = path.resolve(path.dirname(filePath), includeName);
        }
        if (exists(includePath)) {
          if (!includedFiles.has(includePath)) {
            includedFiles.add(includePath);
            processFile(includePath);
          }
          if (index + 1 < lines.length) {
            scheduleLineDirective(filePath, lineNumber + 1);
          }
          continue;
        }
      } else if (!roaringVersion) {
        const match = line.match(ROARING_VERSION_REGEX);
        if (match) {
          roaringVersion = match[1];
          if (!/^[0-9]+\.[0-9]+\.[0-9]+$/.test(roaringVersion)) {
            throw new Error(`Invalid roaring version ${roaringVersion}`);
          }
        }
      }
      pushLine(line);
    }
  }

  processFile(path.resolve(CPP_SRC_FOLDER_PATH, "main.cpp"));

  console.log();
  console.log(colors.cyan(`- roaring version ${roaringVersion}`));

  let outputText = output.join("\n");

  // This is to fix compiling C code with C++ compiler on Windows 2019, to avoid the error
  // C4576: a parenthesized type followed by an initializer list is a non-standard explicit type conversion syntax
  outputText = outputText.replaceAll("(roaring_container_iterator_t){", "roaring_container_iterator_t{");

  console.log(colors.cyanBright(`- Unity: ${includedFiles.size} files included. ${outputText.length} bytes total.`));

  return {
    roaringVersion,
    outputText,
  };
};
