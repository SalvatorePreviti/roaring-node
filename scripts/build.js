#!/usr/bin/env node

const colors = require("chalk");
const path = require("path");
const fs = require("fs");

const ROOT_FOLDER = path.resolve(__dirname, "..");
const SRC_CPP_FOLDER = path.resolve(ROOT_FOLDER, "src/cpp");
const OUTPUT_FILE_PATH = path.resolve(ROOT_FOLDER, "roaring-node.cpp");
const INCLUDE_REGEX = /^#\s*include\s+["<](.+)[">]/;
const ROARING_VERSION = /#\s*define\s+ROARING_VERSION\s+"(.+)"/;
const BINARY_OUTPUT_FILE_PATH = path.resolve(ROOT_FOLDER, "build/Release/roaring.node");

const existsCache = new Map();

const exists = (filePath) => {
  let result = existsCache.get(filePath);
  if (result !== undefined) {
    return result;
  }
  result = fs.existsSync(filePath);
  existsCache.set(filePath, result);
  return result;
};

async function unity() {
  const includedFiles = new Set();
  let roaringVersion = null;

  const output = ['// This file is generated by "scripts/build.js". Do not edit it directly.', ""];

  function processFile(filePath) {
    const content = fs.readFileSync(filePath, "utf8");
    for (const line of content.split("\n")) {
      const includeMatch = line.match(INCLUDE_REGEX);
      if (includeMatch) {
        const includePath = path.resolve(path.dirname(filePath), includeMatch[1]);
        if (exists(includePath)) {
          if (!includedFiles.has(includePath)) {
            output.push(`\n// ${line}\n`);
            includedFiles.add(includePath);
            processFile(includePath);
          }
          continue;
        }
      } else if (!roaringVersion) {
        const match = line.match(ROARING_VERSION);
        if (match) {
          roaringVersion = match[1];
          if (!/^[0-9]+\.[0-9]+\.[0-9]+$/.test(roaringVersion)) {
            throw new Error(`Invalid roaring version ${roaringVersion}`);
          }
        }
      }
      output.push(line);
    }
  }

  processFile(path.resolve(SRC_CPP_FOLDER, "main.cpp"));

  console.log();
  console.log(colors.cyan(`- roaring version ${roaringVersion}`));

  const outputText = output.join("\n");
  console.log(colors.cyanBright(`- ${includedFiles.size} files included. ${outputText.length} bytes total.`));

  let oldContent;
  try {
    oldContent = fs.readFileSync(OUTPUT_FILE_PATH, "utf8");
  } catch {}
  if (oldContent !== outputText) {
    fs.writeFileSync(path.resolve(OUTPUT_FILE_PATH), outputText, "utf8");
    console.log(colors.yellow(`- ${path.relative(ROOT_FOLDER, OUTPUT_FILE_PATH)} updated`));
  } else {
    console.log(colors.blackBright(`- ${path.relative(ROOT_FOLDER, OUTPUT_FILE_PATH)} is up to date`));
  }

  const packageJsonPath = path.resolve(ROOT_FOLDER, "package.json");
  const oldPackageJson = fs.readFileSync(packageJsonPath, "utf8");
  const package = JSON.parse(oldPackageJson);
  package.roaring_version = roaringVersion;
  const newPackageJson = `${JSON.stringify(package, null, 2)}\n`;

  if (newPackageJson !== oldPackageJson) {
    fs.writeFileSync(packageJsonPath, newPackageJson);
    console.log(colors.yellow("- package.json updated"));
  } else {
    console.log(colors.blackBright("- package.json is up to date"));
  }
}

async function development() {
  console.warn(
    colors.yellowBright.underline.bold("WARNING") +
      colors.yellow(": Development mode is enabled. Rebuild for production before publishing."),
  );
  const outputText = `#include "src/cpp/main.cpp"`;
  let oldContent;
  try {
    oldContent = fs.readFileSync(OUTPUT_FILE_PATH, "utf8");
  } catch {}
  if (oldContent !== outputText) {
    fs.writeFileSync(path.resolve(OUTPUT_FILE_PATH), outputText, "utf8");
    console.log(colors.yellow(`- ${path.relative(ROOT_FOLDER, OUTPUT_FILE_PATH)} updated`));
  } else {
    console.log(colors.blackBright(`- ${path.relative(ROOT_FOLDER, OUTPUT_FILE_PATH)} is up to date`));
  }
}

async function build() {
  if (exists(SRC_CPP_FOLDER)) {
    if (process.argv.includes("--dev")) {
      console.time("Development mode");
      await development();
      console.timeEnd("Development mode");
    } else {
      console.time("Unity build");
      await unity();
      console.timeEnd("Unity build");
    }
    console.log();
  }

  console.time("Build");

  process.on("exit", () => {
    console.log();
    console.timeEnd("Build");

    if (exists(BINARY_OUTPUT_FILE_PATH)) {
      console.log();
      console.log(
        colors.green(
          `* ${path.relative(ROOT_FOLDER, BINARY_OUTPUT_FILE_PATH)} compiled. ${
            fs.statSync(BINARY_OUTPUT_FILE_PATH).size
          } bytes`,
        ),
      );
    }
    console.log();
  });

  require("node-gyp/bin/node-gyp.js");
}

build().catch((e) => {
  console.error(e);
});
